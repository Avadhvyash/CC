import {writeFileSync, readFileSync} from 'fs-extra';
import {join} from 'path';
import {LICENSE_BANNER, MATERIAL_VERSION} from '../constants';

// There are no type definitions available for these imports.
const uglify = require('uglify-js');
const sorcery = require('sorcery');

/** Regex that matches downleveled class IIFE expressions. Used to add the pure annotations. */
const classIfeeRegex =
  new RegExp('^(var (\\S+) = )(\\(function \\(\\) \\{[\\n\\r]*(?:    (?:\\/\\*\\*| \\*|\\*\\/|' +
    '\\/\\/)[^\\n\\r]*[\\n\\r]*)*    function \\2\\([^\\)]*\\) \\{[\\n\\r]*)', 'mg');

/** Regex that matches downleveled class IIFE expressions with _extends statements */
const classExtendsIfeeRegex =
  /^(var (\S+) = )(\(function \(_super\) \{[\n\r]*    __extends\(\2, _super\);[\n\r]*)/gm;

/**
 * Finds the original sourcemap of the file and maps it to the current file.
 * This is useful when multiple transformation happen (e.g TSC -> Rollup -> Uglify)
 **/
export async function remapSourcemap(sourceFile: string) {
  // Once sorcery loaded the chain of sourcemaps, the new sourcemap will be written asynchronously.
  return (await sorcery.load(sourceFile)).write();
}

/** Minifies a JavaScript file using UglifyJS2. Also writes sourcemaps to the output. */
export function uglifyFile(inputPath: string, outputPath: string) {
  const sourcemapOut = `${outputPath}.map`;
  const result = uglify.minify(inputPath, {
    preserveComments: 'license',
    outSourceMap: sourcemapOut
  });

  writeFileSync(outputPath, result.code);
  writeFileSync(sourcemapOut, result.map);
}

/** Updates the `package.json` file of the specified package. Replaces the version placeholder. */
export function updatePackageVersion(packageDir: string) {
  const packagePath = join(packageDir, 'package.json');
  const packageConfig = require(packagePath);

  // Replace the `0.0.0-PLACEHOLDER` version name with the version of the root package.json file.
  packageConfig.version = packageConfig.version.replace('0.0.0-PLACEHOLDER', MATERIAL_VERSION);

  writeFileSync(packagePath, JSON.stringify(packageConfig, null, 2));
}

/** Create a typing file that links to the bundled definitions of NGC. */
export function createTypingFile(outputDir: string, entryName: string) {
  writeFileSync(join(outputDir, `${entryName}.d.ts`),
    LICENSE_BANNER + '\nexport * from "./typings/index";'
  );
}

/** Creates a metadata file that re-exports the metadata bundle inside of the typings. */
export function createMetadataFile(packageDir: string, packageName: string) {
  const metadataReExport =
    `{"__symbolic":"module","version":3,"metadata":{},"exports":[{"from":"./typings/index"}]}`;
  writeFileSync(join(packageDir, `${packageName}.metadata.json`), metadataReExport, 'utf-8');
}

/**
 * Adds `@__PURE__` annotation comments to IIFEs containing ES5-downleveled classes generated by
 * TypeScript so that Uglify can tree-shake classes that are not referenced.
 *
 * @param fileContent The content of the file for which `@__PURE__` will be added.
 * @returns The content of the file with `@__PURE__` annotations added.
 */
export function addPureAnnotations(fileContent: string) {
  return fileContent
    // Prefix downleveled classes w/ the @__PURE__ annotation.
    .replace(classIfeeRegex, '$1/*@__PURE__*/$3')
    // Prefix downleveled classes that extend another class w/ the @__PURE__ annotation
    .replace(classExtendsIfeeRegex, '$1/*@__PURE__*/$3');
}

/** Adds Uglify "@__PURE__" decorations to the specified file. */
export function addPureAnnotationsToFile(inputFile: string) {
  const originalContent = readFileSync(inputFile, 'utf-8');
  const annotatedContent = addPureAnnotations(originalContent);

  writeFileSync(inputFile, annotatedContent, 'utf-8');
}

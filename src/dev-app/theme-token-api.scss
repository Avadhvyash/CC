@use 'sass:map';
@use '@angular/material' as mat;
@use '@angular/material-experimental';

dev-app {
  &::before {
    content: 'Using experimental theming API';
    display: inline-block;
    position: fixed;
    z-index: 100;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px;
    background: red;
    color: white;
  }
}

.demo-unicorn-dark-theme {
  background: black;
  color: white;
}

@include mat.core();

$light-theme: mat.define-light-theme((
  color: (
      primary: mat.define-palette(mat.$indigo-palette),
      accent: mat.define-palette(mat.$pink-palette),
  ),
  typography: mat.define-typography-config(),
  density: 0
));

// Apply all checkbox tokens (derived from `$light-theme`) to the `body` element.
// This ensures that all checkboxes within the body inherit these tokens.
@include material-experimental.theme($tokens: mat.m2-tokens-from-theme($light-theme), $components: (
  material-experimental.checkbox(),
));

// Apply tokens related to the theme type to any element with `.demo-unicorn-dark-theme`.
// This ensures that checkboxes within the element inherit the new tokens for dark theme,
// rather than the ones for light theme set on `body`.
.demo-unicorn-dark-theme {
  @include material-experimental.update-theme($components: (
    material-experimental.checkbox((
      theme-type: dark
    )),
  ));
}

// Apply tokens related to the color palette to any element with `.mat-primary`.
// This ensures that checkboxes within the element inherit the new tokens for primary color,
// rather than the any color that may have been set on an element further up the hierarchy.
.mat-primary {
  @include material-experimental.update-theme($components: (
    material-experimental.checkbox((
      color-palette: map.get($light-theme, color, primary)
    )),
  ));
}

// Apply tokens related to the color palette to any element with `.mat-accent`.
// This ensures that checkboxes within the element inherit the new tokens for accent color,
// rather than the any color that may have been set on an element further up the hierarchy.
.mat-accent {
  @include material-experimental.update-theme($components: (
    material-experimental.checkbox((
      color-palette: map.get($light-theme, color, accent)
    )),
  ));
}

// Apply tokens related to the color palette to any element with `.mat-warn`.
// This ensures that checkboxes within the element inherit the new tokens for warn color,
// rather than the any color that may have been set on an element further up the hierarchy.
.mat-warn {
  @include material-experimental.update-theme($components: (
    material-experimental.checkbox((
      color-palette: map.get($light-theme, color, warn)
    )),
  ));
}

// NOTE:
// A nice feature about the theme styles defined above is that they stack well. For example:
//
// <body class="demo-unicorn-dark-theme">
//   <mat-checkbox class="mat-primary">
// </body>
//
// The above checkbox will inherit its border color from `.demo-unicorn-dark-theme` and its fill
// color from `.mat-primary` resulting in a checkbox with a white border and a primary colored fill.
// It also works nicely with deeper nesting that used to be problematic. For example:
//
// <body>
//   <div class="mat-warn">
//     <div class="mat-accent>
//       <div class="mat-primary">
//         <mat-checkbox></mat-checkbox>
//       </div>
//     </div>
//   </div>
// </body>
//
// The checkbox above is correctly colored with the primary color. This works because we don't have
// to rely on rule specificity to determine which style gets applied, instead each layer of
// `mat-warn`, `mat-accent`, `mat-primary` defines the custom property itself, preventing it from
// being inherited from the level above.
//
// The key to getting this nice behavior is that the the theme mixin must not emit deeply nested
// styles. It should always emit the tokens at the root selector where its `@include` is.
// If the tokens were instead targeted at selectors like `body mat-checkbox`,
// `.mat-primary mat-checkbox`, this would break down because we would again be depending on
// specificity to decide which token value is applied.

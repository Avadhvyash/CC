@use 'sass:map';
@use '@material/ripple/ripple-theme' as mdc-ripple-theme;
@use '../../material/core/ripple/ripple-theme';

// The MDC button's ripple ink color is based on the theme color, not on the foreground base
// which is what the ripple mixin uses. This creates a new theme that sets the color to the
// foreground base to appropriately color the ink.
@mixin ripple-ink-color($color) {
  @include ripple-theme.color((
    foreground: (
      base: $color
    ),
  ));
}

// MDC's ripple opacity depends on whether the theme is dark or light.
// This function adds the correct mapping to the theme tokens.
@function add-ripple-opacities($is-dark-theme, $tokens: ()) {
  $opacities: if($is-dark-theme,
    mdc-ripple-theme.$light-ink-opacities, mdc-ripple-theme.$dark-ink-opacities);
  @return map.merge($tokens, (
    focus-state-layer-opacity: map.get($opacities, focus),
    hover-state-layer-opacity: map.get($opacities, hover),
    pressed-state-layer-opacity: map.get($opacities, press),
  ));
}

// Wraps the content style in a selector for the disabled state.
// MDC adds theme color by using :not(:disabled), so just using [disabled] once will not
// override this, neither will it apply to anchor tags. This needs to override the
// previously set theme color, so it must be ordered after the theme styles.
// TODO(andrewseguin): Discuss with the MDC team to see if we can avoid the :not(:disabled) by
// manually styling disabled buttons with a [disabled] selector.
@mixin apply-disabled-style() {
  &[disabled][disabled] {
    @content;
  }
}

// Hides the touch target on lower densities.
@mixin touch-target-density($scale) {
  @if ($scale == -2 or $scale == 'minimum') {
    .mat-mdc-button-touch-target {
      display: none;
    }
  }
}
